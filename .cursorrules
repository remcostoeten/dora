# Dora Database Client - Architecture Rules

## Domain-Driven Architecture

This project follows a domain-driven architecture with co-located modules. All code related to a specific feature/domain should be located in its own folder under `src/domains/`.

## Folder Structure Standards

### Domain Module Template
```
src/domains/domain-name/
├── components/           # React components for this domain
├── hooks/                # Domain-specific React hooks
├── api/                  # Tauri/API commands for this domain
├── utils/                # Pure utility functions for this domain
├── types.ts              # Domain-specific types
├── constants.ts          # Domain constants (optional)
└── index.ts              # Public exports only
```

### Shared Code Structure
```
src/shared/
├── components/
│   ├── ui/               # Primitive UI components (button, input, etc.)
│   ├── layout/           # App shell components (sidebar, titlebar)
│   └── common/           # Shared components (logo, theme-switcher)
├── hooks/                # App-wide hooks
├── state/                # Global state management
├── lib/                  # External integrations (tauri, formatters)
└── types/                # Shared types
```

## Naming Conventions

### Files
- Use kebab-case for all files: `connection-form.tsx`, `use-connections.ts`
- Component files end with `.tsx`
- Hook files start with `use-`: `use-connections.ts`
- API files end with `-commands.ts`: `connection-commands.ts`
- Type files: `types.ts`
- Index files: `index.ts` (always present)

### Components
- Use PascalCase for component names: `ConnectionForm`, `QueryHistory`
- Exported props types: `ComponentNameProps` (e.g., `ConnectionFormProps`)
- Non-exported props types: Use `Props` when there's only one non-exported type in the file

### Folders
- Use kebab-case: `data-browser`, `connection-history`

## Import Rules

### Domain Imports
```typescript
// GOOD - Import from domain index
import { ConnectionForm, useConnections } from '@/domains/connections'

// BAD - Import deep paths
import { ConnectionForm } from '@/domains/connections/components/connection-form'
```

### Shared Imports
```typescript
// GOOD - Import from shared
import { Button } from '@/shared/components/ui'
import { useResizable } from '@/shared/hooks'
```

## Component Guidelines

### Component Size
- Keep components under 300 lines
- Split large components into smaller, focused ones
- Use composition over inheritance

### State Management
- Domain-specific state goes in domain hooks
- Global state goes in `src/shared/state/`
- Use the pattern: `use[Domain]()` for domain hooks

### File Organization
- One component per file
- Export as default from component file
- Re-export from domain index

## Domain Boundaries

### What Goes in Domains?
- Feature-specific UI components
- Feature-specific business logic
- Feature-specific API calls
- Feature-specific types
- Feature-specific utilities

### What Goes in Shared?
- Reusable UI primitives
- App-wide state management
- Cross-cutting concerns (theming, layout)
- External integrations
- Base types and utilities

## Code Quality Rules

### No God Components
- Break down components over 200 lines
- Extract logic into custom hooks
- Use container/presenter pattern when needed

### Consistent Exports
- Every domain must have an `index.ts`
- Export public API only from index
- Use named exports, not default exports from index

### Type Safety
- **Always use `type` instead of `interface`** unless not possible otherwise
- All components must have TypeScript types for props
- Use strict TypeScript settings
- Prefer explicit types over `any`
- For non-exported single types (e.g., component props), always name them `Props`

## Testing Structure

Mirror the source structure:
```
src/__tests__/domains/
├── connections/
├── queries/
└── schema/
```

## Migration Guidelines

When migrating existing code:
1. Create the domain folder structure
2. Move related files together
3. Update imports to use domain index
4. Create proper index exports
5. Update type definitions

## Examples

### Creating a New Domain
```typescript
// src/domains/my-feature/index.ts
export { MyFeature } from './components/my-feature'
export { useMyFeature } from './hooks/use-my-feature'
export { myFeatureCommands } from './api/my-feature-commands'
export type { MyFeatureProps } from './types'
```

### Domain Component
```typescript
// src/domains/connections/components/connection-form.tsx
import type { ConnectionFormProps } from '../types'

export function ConnectionForm({ onSubmit }: ConnectionFormProps) {
  // Component logic
}
```

### Domain Hook
```typescript
// src/domains/connections/hooks/use-connections.ts
import { useState } from 'react'
import { connectionCommands } from '../api'

export function useConnections() {
  // Hook logic
}
```

---

## AI Agent Instructions

### When Working on This Codebase

#### 1. **Always Check Domain Structure First**
- Before making changes, identify which domain the feature belongs to
- Check if the domain already exists in `src/domains/`
- Use the established folder structure for consistency

#### 2. **Import Strategy**
- Always import from domain index files: `import { Component } from '@/domains/domain-name'`
- Never import deep paths unless absolutely necessary
- Use shared imports for UI primitives: `import { Button } from '@/shared/components/ui'`

#### 3. **Component Creation**
- Keep components under 300 lines
- Extract complex logic into domain hooks
- Use proper TypeScript interfaces for props
- Follow naming conventions: `ComponentNameProps` for interfaces

#### 4. **Hook Development**
- Domain hooks should be named `use[Domain]()`
- Keep hooks focused and single-purpose
- Return consistent object structures
- Handle loading states and error states properly

#### 5. **Type Safety**
- Never use `any` - use proper TypeScript types
- Define types in domain `types.ts` files
- Export types from domain index
- Use shared types for cross-domain concerns

#### 6. **File Organization**
- One component per file
- One hook per file
- Always create `index.ts` exports
- Follow the established folder patterns

#### 7. **Error Handling**
- Use the shared toast system with proper variant types ('error', not 'destructive')
- Handle loading states consistently
- Provide meaningful error messages

#### 8. **Before Making Changes**
- Read existing code patterns in the domain
- Check for similar implementations in other domains
- Ensure imports are correct and from proper sources
- Verify component props match expected interfaces

#### 9. **Testing Your Changes**
- Ensure all imports resolve correctly
- Check TypeScript compilation
- Verify component props match interfaces
- Test that exports work from domain index

#### 10. **Common Pitfalls to Avoid**
- Don't create files outside the established structure
- Don't use deep import paths
- Don't mix concerns between domains
- Don't create god components
- Don't use `any` types
- Don't forget to update index exports

### Quick Reference

#### Domain Structure Checklist
- [ ] Domain folder exists in `src/domains/`
- [ ] Has `components/`, `hooks/`, `api/`, `types.ts`, `index.ts`
- [ ] Components export from domain index
- [ ] Types are properly defined and exported
- [ ] Imports use domain index paths

#### Component Checklist
- [ ] Component name follows PascalCase
- [ ] Props interface follows `ComponentNameProps` pattern
- [ ] Component is under 300 lines
- [ ] Complex logic extracted to hooks
- [ ] Proper TypeScript types used

#### Import Checklist
- [ ] Imports from domain index: `@/domains/domain-name`
- [ ] Shared imports from `@/shared/`
- [ ] No deep path imports
- [ ] All imports resolve correctly

---

**Remember**: The goal is co-location, discoverability, and maintainability. Everything related to a feature should be in one place, and the structure should be consistent across all domains.
