// @ts-nocheck
// Auto-generated by tauri-specta. DO NOT EDIT.


// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async minimizeWindow() : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("minimize_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async maximizeWindow() : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("maximize_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async closeWindow() : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openSqliteDb() : Promise<Result<string | null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_sqlite_db") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveSqliteDb() : Promise<Result<string | null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_sqlite_db") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openFile(title: string | null) : Promise<Result<string | null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_file", { title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addConnection(name: string, databaseInfo: DatabaseInfo, color: number | null) : Promise<Result<ConnectionInfo, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_connection", { name, databaseInfo, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateConnection(connId: string, name: string, databaseInfo: DatabaseInfo, color: number | null) : Promise<Result<ConnectionInfo, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_connection", { connId, name, databaseInfo, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateConnectionColor(connectionId: string, color: number | null) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_connection_color", { connectionId, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async connectToDatabase(connectionId: string) : Promise<Result<boolean, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("connect_to_database", { connectionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async disconnectFromDatabase(connectionId: string) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("disconnect_from_database", { connectionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getConnections() : Promise<Result<ConnectionInfo[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_connections") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeConnection(connectionId: string) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_connection", { connectionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async testConnection(databaseInfo: DatabaseInfo) : Promise<Result<boolean, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("test_connection", { databaseInfo }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async initializeConnections() : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("initialize_connections") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecentConnections(limit: number | null) : Promise<Result<ConnectionInfo[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_connections", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getConnectionHistory(dbTypeFilter: string | null, successFilter: boolean | null, limit: number | null) : Promise<Result<ConnectionHistoryEntry[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_connection_history", { dbTypeFilter, successFilter, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setConnectionPin(connectionId: string, pin: string | null) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_connection_pin", { connectionId, pin }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async verifyPinAndGetCredentials(connectionId: string, pin: string) : Promise<Result<string | null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("verify_pin_and_get_credentials", { connectionId, pin }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startQuery(connectionId: string, query: string) : Promise<Result<number[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_query", { connectionId, query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchQuery(queryId: number) : Promise<Result<StatementInfo, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_query", { queryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPage(queryId: number, pageIndex: number) : Promise<Result<JsonValue | null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_page", { queryId, pageIndex }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getQueryStatus(queryId: number) : Promise<Result<QueryStatus, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_query_status", { queryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPageCount(queryId: number) : Promise<Result<number, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_page_count", { queryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getColumns(queryId: number) : Promise<Result<JsonValue | null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_columns", { queryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveQueryToHistory(connectionId: string, query: string, durationMs: number | null, status: string, rowCount: number, errorMessage: string | null) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_query_to_history", { connectionId, query, durationMs, status, rowCount, errorMessage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getQueryHistory(connectionId: string, limit: number | null) : Promise<Result<QueryHistoryEntry[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_query_history", { connectionId, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startLiveMonitor(connectionId: string, tableName: string, intervalMs: number, changeTypes: LiveMonitorChangeType[]) : Promise<Result<LiveMonitorSession, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_live_monitor", { connectionId, tableName, intervalMs, changeTypes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopLiveMonitor(monitorId: string) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_live_monitor", { monitorId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecentQueries(connectionId: string | null, limit: number | null, statusFilter: string | null) : Promise<Result<QueryHistoryEntry[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_queries", { connectionId, limit, statusFilter }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveScript(name: string, content: string, connectionId: string | null, description: string | null) : Promise<Result<number, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_script", { name, content, connectionId, description }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateScript(id: number, name: string, content: string, connectionId: string | null, description: string | null) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_script", { id, name, content, connectionId, description }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getScripts(connectionId: string | null) : Promise<Result<SavedQuery[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_scripts", { connectionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteScript(id: number) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_script", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSnippets(languageFilter: string | null, isSystemFilter: boolean | null, categoryFilter: string | null) : Promise<Result<SavedQuery[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_snippets", { languageFilter, isSystemFilter, categoryFilter }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveSnippet(name: string, content: string, language: string | null, tags: string | null, category: string | null, connectionId: string | null, description: string | null, folderId: number | null) : Promise<Result<number, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_snippet", { name, content, language, tags, category, connectionId, description, folderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateSnippet(id: number, name: string, content: string, language: string | null, tags: string | null, category: string | null, description: string | null, folderId: number | null, connectionId: string | null) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_snippet", { id, name, content, language, tags, category, description, folderId, connectionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteSnippet(id: number) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_snippet", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async seedSystemSnippets() : Promise<Result<number, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("seed_system_snippets") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSnippetFolders() : Promise<Result<SnippetFolder[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_snippet_folders") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createSnippetFolder(name: string, parentId: number | null, color: string | null) : Promise<Result<number, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_snippet_folder", { name, parentId, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateSnippetFolder(id: number, name: string, color: string | null) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_snippet_folder", { id, name, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteSnippetFolder(id: number) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_snippet_folder", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveSessionState(sessionData: string) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_session_state", { sessionData }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSessionState() : Promise<Result<string | null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_session_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSetting(key: string) : Promise<Result<string | null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_setting", { key }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSetting(key: string, value: string) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_setting", { key, value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async insertRow(connectionId: string, tableName: string, schemaName: string | null, rowData: Partial<{ [key in string]: JsonValue }>) : Promise<Result<MutationResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("insert_row", { connectionId, tableName, schemaName, rowData }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCell(connectionId: string, tableName: string, schemaName: string | null, primaryKeyColumn: string, primaryKeyValue: JsonValue, columnName: string, newValue: JsonValue) : Promise<Result<MutationResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_cell", { connectionId, tableName, schemaName, primaryKeyColumn, primaryKeyValue, columnName, newValue }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteRows(connectionId: string, tableName: string, schemaName: string | null, primaryKeyColumn: string, primaryKeyValues: JsonValue[]) : Promise<Result<MutationResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_rows", { connectionId, tableName, schemaName, primaryKeyColumn, primaryKeyValues }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async duplicateRow(connectionId: string, tableName: string, schemaName: string | null, primaryKeyColumn: string, primaryKeyValue: JsonValue) : Promise<Result<MutationResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("duplicate_row", { connectionId, tableName, schemaName, primaryKeyColumn, primaryKeyValue }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportTable(connectionId: string, tableName: string, schemaName: string | null, format: ExportFormat, limit: number | null) : Promise<Result<string, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_table", { connectionId, tableName, schemaName, format, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async softDeleteRows(connectionId: string, tableName: string, schemaName: string | null, primaryKeyColumn: string, primaryKeyValues: JsonValue[], softDeleteColumn: string | null) : Promise<Result<SoftDeleteResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("soft_delete_rows", { connectionId, tableName, schemaName, primaryKeyColumn, primaryKeyValues, softDeleteColumn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async undoSoftDelete(connectionId: string, tableName: string, schemaName: string | null, primaryKeyColumn: string, primaryKeyValues: JsonValue[], softDeleteColumn: string) : Promise<Result<MutationResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("undo_soft_delete", { connectionId, tableName, schemaName, primaryKeyColumn, primaryKeyValues, softDeleteColumn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async truncateTable(connectionId: string, tableName: string, schemaName: string | null, cascade: boolean | null) : Promise<Result<TruncateResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("truncate_table", { connectionId, tableName, schemaName, cascade }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async truncateDatabase(connectionId: string, schemaName: string | null, confirm: boolean) : Promise<Result<TruncateResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("truncate_database", { connectionId, schemaName, confirm }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dumpDatabase(connectionId: string, outputPath: string) : Promise<Result<DumpResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dump_database", { connectionId, outputPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async executeBatch(connectionId: string, statements: string[]) : Promise<Result<MutationResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("execute_batch", { connectionId, statements }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDatabaseSchema(connectionId: string) : Promise<Result<DatabaseSchema, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_database_schema", { connectionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDatabaseMetadata(connectionId: string) : Promise<Result<DatabaseMetadata, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_database_metadata", { connectionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async seedTable(connectionId: string, tableName: string, schemaName: string | null, count: number) : Promise<Result<SeedResult, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("seed_table", { connectionId, tableName, schemaName, count }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async parseSql(sql: string) : Promise<Result<JsonValue, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("parse_sql", { sql }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async buildSql(ast: JsonValue) : Promise<Result<string, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("build_sql", { ast }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Export database schema to SQL DDL format
 * 
 * # Arguments
 * * `connection_id` - UUID of the connected database
 * * `dialect` - Target SQL dialect: "postgresql" or "sqlite"
 */
async exportSchemaSql(connectionId: string, dialect: string) : Promise<Result<string, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_schema_sql", { connectionId, dialect }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Export database schema to Drizzle ORM TypeScript format
 * 
 * # Arguments
 * * `connection_id` - UUID of the connected database
 * * `dialect` - Target Drizzle dialect: "postgresql" or "sqlite"
 */
async exportSchemaDrizzle(connectionId: string, dialect: string) : Promise<Result<string, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_schema_drizzle", { connectionId, dialect }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Complete a prompt using the configured AI provider
 */
async aiComplete(prompt: string, connectionId: string | null, maxTokens: number | null) : Promise<Result<AIResponse, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ai_complete", { prompt, connectionId, maxTokens }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set the AI provider (gemini or ollama)
 */
async aiSetProvider(provider: string) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ai_set_provider", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current AI provider
 */
async aiGetProvider() : Promise<Result<string, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ai_get_provider") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set the Gemini API key (BYOK)
 */
async aiSetGeminiKey(apiKey: string) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ai_set_gemini_key", { apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Configure Ollama endpoint and model
 */
async aiConfigureOllama(endpoint: string | null, model: string | null) : Promise<Result<null, any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ai_configure_ollama", { endpoint, model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List available Ollama models
 */
async aiListOllamaModels() : Promise<Result<string[], any>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ai_list_ollama_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AIResponse = { content: string; suggested_queries: string[] | null; tokens_used: number | null; provider: string }
export type ColumnInfo = { name: string; data_type: string; is_nullable: boolean; default_value: string | null; 
/**
 * Whether this column is part of the primary key
 */
is_primary_key?: boolean; 
/**
 * Whether this column auto-increments (SERIAL, AUTOINCREMENT, etc.)
 */
is_auto_increment?: boolean; 
/**
 * Foreign key relationship, if any
 */
foreign_key?: ForeignKeyInfo | null }
export type ConnectionHistoryEntry = { id: number; connection_id: string; connection_name: string; database_type: string; attempted_at: number; success: boolean; error_message: string | null; duration_ms: number | null }
export type ConnectionInfo = { id: string; name: string; connected: boolean; database_type: DatabaseInfo; last_connected_at: number | null; created_at: number | null; updated_at: number | null; pin_hash: string | null; favorite: boolean | null; color: string | null; sort_order: number | null }
export type DatabaseInfo = { Postgres: { connection_string: string; ssh_config: SshConfig | null } } | { SQLite: { db_path: string } } | 
/**
 * LibSQL/Turso database - can be local path or remote URL with auth token
 */
{ LibSQL: { 
/**
 * Either a local file path or remote URL (libsql://...)
 */
url: string; 
/**
 * Auth token for remote connections (optional for local)
 */
auth_token: string | null } }
/**
 * Database-level metadata information
 */
export type DatabaseMetadata = { 
/**
 * Total size of the database in bytes
 */
size_bytes: number; 
/**
 * Database creation timestamp (if available)
 */
created_at: number | null; 
/**
 * Last modification timestamp (if available)
 */
last_updated: number | null; 
/**
 * Total number of rows across all tables
 */
row_count_total: number; 
/**
 * Number of tables in the database
 */
table_count: number; 
/**
 * Database host or file path
 */
host: string; 
/**
 * Database name
 */
database_name: string | null }
export type DatabaseSchema = { tables: TableInfo[]; schemas: string[]; unique_columns: string[] }
/**
 * Result of a database dump operation
 */
export type DumpResult = { success: boolean; file_path: string; size_bytes: number; tables_dumped: number; rows_dumped: number; message: string | null }
/**
 * Export format options
 */
export type ExportFormat = "json" | "sql_insert" | "csv"
/**
 * Information about a foreign key relationship
 */
export type ForeignKeyInfo = { 
/**
 * The table that this foreign key references
 */
referenced_table: string; 
/**
 * The column in the referenced table
 */
referenced_column: string; 
/**
 * The schema of the referenced table (empty for SQLite)
 */
referenced_schema: string }
export type IndexInfo = { name: string; column_names: string[]; is_unique: boolean; is_primary: boolean }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>
export type LiveMonitorChangeType = "insert" | "update" | "delete"
export type LiveMonitorSession = { monitorId: string; eventName: string }
/**
 * Result of a mutation operation
 */
export type MutationResult = { success: boolean; affected_rows: number; message: string | null }
export type QueryHistoryEntry = { id: number; connection_id: string; query_text: string; executed_at: number; duration_ms: number | null; status: string; row_count: number; error_message: string | null }
export type QueryStatus = "Pending" | "Running" | "Completed" | "Error"
export type SavedQuery = { id: number; name: string; description: string | null; query_text: string; connection_id: string | null; tags: string | null; category: string | null; created_at: number; updated_at: number; favorite: boolean; is_snippet: boolean; is_system: boolean; language: string | null; folder_id: number | null }
export type SeedResult = { rows_inserted: number; table: string }
export type SnippetFolder = { id: number; name: string; parent_id: number | null; color: string | null; created_at: number; updated_at: number }
/**
 * Result of a soft delete operation
 */
export type SoftDeleteResult = { success: boolean; affected_rows: number; message: string | null; 
/**
 * Unix timestamp when deletion happened (for undo window)
 */
deleted_at: number; 
/**
 * How many seconds the undo window lasts
 */
undo_window_seconds: number }
export type SshConfig = { host: string; port: number; username: string; private_key_path: string | null; password: string | null }
export type StatementInfo = { returns_values: boolean; status: QueryStatus; first_page: JsonValue; affected_rows: number | null; error: string | null }
export type TableInfo = { name: string; schema: string; columns: ColumnInfo[]; 
/**
 * Names of columns that form the primary key (supports composite keys)
 */
primary_key_columns?: string[]; 
/**
 * List of indexes on this table
 */
indexes?: IndexInfo[]; 
/**
 * Estimated row count (may be approximate for performance)
 */
row_count_estimate?: number | null }
/**
 * Result of a truncate operation
 */
export type TruncateResult = { success: boolean; affected_rows: number; tables_truncated: string[]; message: string | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
